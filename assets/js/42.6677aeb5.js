(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{455:function(t,e,a){"use strict";a.r(e);var v=a(2),s=Object(v.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"共有特点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#共有特点"}},[t._v("#")]),t._v(" 共有特点")]),t._v(" "),e("h2",{attrs:{id:"虚拟dom"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom"}},[t._v("#")]),t._v(" 虚拟DOM")]),t._v(" "),e("p",[t._v("只是一层对真实DOM的抽象，以JavaScript 对象 (VNode 节点) 作为基础的树，用对象的属性来描述节点，每个 VNode 有 children，children 每个元素也是一个VNode，这样就形成了一个虚拟树结构，用于描述真实的DOM树结构，最终可以通过一系列操作使这棵树映射到真实环境上。")]),t._v(" "),e("p",[t._v("优点：操作DOM是很慢的，其元素非常庞大，页面的性能问题，大部分都是由DOM操作引起的，真实的DOM节点，哪怕一个最简单的div也包含着很多属性，频繁操作还是会出现页面卡顿，影响用户的体验。通过VNode，同样更新10个DOM节点，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地的一个js对象中，最终将这个js对象一次性attach到DOM树上，避免大量的无谓计算，减少 JavaScript 操作真实 DOM 的带来的性能消耗。虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种GUI实现了跨平台的能力。")]),t._v(" "),e("h2",{attrs:{id:"组件和插件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组件和插件"}},[t._v("#")]),t._v(" 组件和插件")]),t._v(" "),e("h3",{attrs:{id:"组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组件"}},[t._v("#")]),t._v(" 组件：")]),t._v(" "),e("p",[t._v("组件就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在Vue中每一个.vue文件都可以视为一个组件")]),t._v(" "),e("p",[t._v("组件的优势")]),t._v(" "),e("ul",[e("li",[t._v("降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现")]),t._v(" "),e("li",[t._v("调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单")]),t._v(" "),e("li",[t._v("提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级")])]),t._v(" "),e("h3",{attrs:{id:"插件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#插件"}},[t._v("#")]),t._v(" 插件：")]),t._v(" "),e("p",[t._v("插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种：")]),t._v(" "),e("ul",[e("li",[t._v("添加全局方法或者属性。如: vue-custom-element")]),t._v(" "),e("li",[t._v("添加全局资源：指令/过滤器/过渡等。如 vue-touch")]),t._v(" "),e("li",[t._v("通过全局混入来添加一些组件选项。如vue-router")]),t._v(" "),e("li",[t._v("添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。")]),t._v(" "),e("li",[t._v("一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如vue-router")])]),t._v(" "),e("h3",{attrs:{id:"区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[t._v("#")]),t._v(" 区别")]),t._v(" "),e("h4",{attrs:{id:"编写形式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#编写形式"}},[t._v("#")]),t._v(" 编写形式")]),t._v(" "),e("p",[t._v("编写一个组件，可以有很多方式，我们最常见的就是vue单文件的这种格式，每一个.vue文件我们都可以看成是一个组件")]),t._v(" "),e("p",[t._v("vue插件的实现应该暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象")]),t._v(" "),e("h4",{attrs:{id:"注册形式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#注册形式"}},[t._v("#")]),t._v(" 注册形式")]),t._v(" "),e("p",[t._v("vue组件注册主要分为全局注册与局部注册")]),t._v(" "),e("p",[t._v("全局注册通过Vue.component方法，第一个参数为组件的名称，第二个参数为传入的配置项")]),t._v(" "),e("p",[t._v("局部注册只需在用到的地方通过components属性注册一个组件")]),t._v(" "),e("p",[t._v("插件的注册通过Vue.use()的方式进行注册（安装），第一个参数为插件的名字，第二个参数是可选择的配置项")]),t._v(" "),e("p",[t._v("需要注意的是：")]),t._v(" "),e("p",[t._v("注册插件的时候，需要在调用 new Vue() 启动应用之前完成，Vue.use会自动阻止多次注册相同插件，只会注册一次")]),t._v(" "),e("h4",{attrs:{id:"使用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用场景"}},[t._v("#")]),t._v(" 使用场景")]),t._v(" "),e("p",[t._v("组件 (Component) 是用来构成你的 App 的业务模块，它的目标是 App.vue")]),t._v(" "),e("p",[t._v("插件 (Plugin) 是用来增强你的技术栈的功能模块，它的目标是 Vue 本身")]),t._v(" "),e("p",[t._v("简单来说，插件就是指对Vue的功能的增强或补充")]),t._v(" "),e("h1",{attrs:{id:"vue"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[t._v("#")]),t._v(" Vue")]),t._v(" "),e("h2",{attrs:{id:"mvvm简述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mvvm简述"}},[t._v("#")]),t._v(" MVVM简述")]),t._v(" "),e("p",[t._v("一种架构思想")]),t._v(" "),e("p",[t._v("视图模型双向绑定就是MVVM，是model-view-viewModel的缩写，就是把MCV的控制层(Controller)演变成viewModel。model是数据模型，view代表UI组件，viewModel是view和model的桥梁，视图变化时会通知viewModel更新model，反之，model中数据变化也将会自动展示在页面上")]),t._v(" "),e("p",[e("strong",[t._v("MVVM优点：")])]),t._v(" "),e("p",[t._v("低耦合：视图（View）可以独立于Model变化和修改，一个Model可以绑定到不同的View上，当View变化的时候Model可以不变化，当Model变化的时候View也可以不变")]),t._v(" "),e("p",[t._v("可重用性：你可以把一些视图逻辑放在一个Model里面，让很多View重用这段视图逻辑")]),t._v(" "),e("p",[t._v("独立开发：开发人员可以专注于业务逻辑和数据的开发(ViewModel)，设计人员可以专注于页面设计")]),t._v(" "),e("h2",{attrs:{id:"vue通讯方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue通讯方式"}},[t._v("#")]),t._v(" Vue通讯方式")]),t._v(" "),e("p",[t._v("props：父组件传递数据给子组件")]),t._v(" "),e("p",[t._v("$emits：子组件传递数据给父组件")]),t._v(" "),e("p",[t._v("ref：通过$refs获取的是子组件的vue实例")]),t._v(" "),e("p",[t._v("EventBus【中间人传参】vue3中使用mitt：兄弟组件传值")]),t._v(" "),e("p",[t._v("$parent 或$root：root 和parent 都能够实现访问父组件的属性和方法，两者的区别在于，如果存在多级子组件，通过parent 访问得到的是它最近一级的父组件，通过root 访问得到的是根父组件")]),t._v(" "),e("p",[t._v("$attrs 与 $listeners：祖先传递数据给子孙")]),t._v(" "),e("p",[t._v("Provide 与 Inject：provide和inject是成对出现的。用于父组件向子孙组件传递数据")]),t._v(" "),e("p",[t._v("Vuex：复杂关系的组件数据传递")]),t._v(" "),e("h2",{attrs:{id:"vue响应式实现原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue响应式实现原理"}},[t._v("#")]),t._v(" Vue响应式实现原理")]),t._v(" "),e("p",[t._v("vue是采用数据劫持结合发布者-订阅者的方法通过Object.defineProperty()来劫持各个属性的setter和getter，在数据变动时发布消息给订阅者，触发对应监听回调，Vue是典型的MVVM框架吗，model只是普通的JavaScript对象，修改它则view会自动更新，这使得状态管理变得简单直观")]),t._v(" "),e("p",[t._v("Observer(数据监听器)：Observer核心就是通过Object.defineProprtty来监听数据的变动，这个函数内部可以定义setter和getter，每当数据发生变化就会触发setter，这个时候Observer就要通知订阅者，订阅者就是watcher")]),t._v(" "),e("p",[t._v("Watcher(订阅者)：Watcher作为Observer和Comoile之间通信的桥梁，主要做：")]),t._v(" "),e("ul",[e("li",[t._v("自身实例化时往属性订阅去(dep)里面添加自己")]),t._v(" "),e("li",[t._v("自身必须有一个update方法")]),t._v(" "),e("li",[t._v("属性变动dep.notice通知时，能调用自身的update方法，触发Compile绑定中的回调")])]),t._v(" "),e("p",[t._v("Compile(指令解析器)：Compile就是模板解析器，用来解析vue的html，将模板中变量替换成数据，然后初始化渲染页面视图，并且为每个指令对应的节点绑定更新函数，添加数据的订阅者，一旦数据有变化，通知更新视图")]),t._v(" "),e("h2",{attrs:{id:"vue生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue生命周期"}},[t._v("#")]),t._v(" Vue生命周期")]),t._v(" "),e("p",[t._v("beforeCreate: 创建前，此时data和methods中的数据都还没有初始化")]),t._v(" "),e("p",[t._v("created： 创建完毕，data中有值，未挂载")]),t._v(" "),e("p",[e("strong",[t._v("子组件更新阶段")]),t._v("：父beforeUpdate->子beforeUpdate->子updated->父updated")]),t._v(" "),e("p",[t._v("**销毁阶段：**父beforeDestroy->子beforeDestroy->子destroyed->父destroyed")]),t._v(" "),e("h2",{attrs:{id:"computed和watch"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#computed和watch"}},[t._v("#")]),t._v(" computed和watch")]),t._v(" "),e("p",[t._v("区别：计算属性是用来声明式的描述一个值依赖了其他值，当所依赖的值或者变量改变时，计算属性会跟着改变，监听器监听的是data中定义的变量，变量变化时执行watch中的方法")]),t._v(" "),e("p",[t._v("计算属性的结果会被缓存，当计算属性依赖的属性没有变化时，调用当前函数的结果会从缓存中读取，除非依赖的响应式属性发生变化才会重新计算。计算属性必须用return返回最终结果，计算属性更加高效，推荐优先使用，data不变计算属性不更新。")]),t._v(" "),e("p",[t._v("监听器是一个对象，键时需要观察的属性吗，值为对应回调函数，值也可能为对象来配置深度监听或者首次加载触发监听器")]),t._v(" "),e("h2",{attrs:{id:"data为什么是一个函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#data为什么是一个函数"}},[t._v("#")]),t._v(" data为什么是一个函数")]),t._v(" "),e("p",[t._v("一个组件被复用多次是会创建多个实例，本质上这些实例用的都是同一个构造函数，如果data是对象的话，对象属于引用类型，会影响到所有的实例，data必须是一个函数")]),t._v(" "),e("h2",{attrs:{id:"v-for和v-if不建议用在一起"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#v-for和v-if不建议用在一起"}},[t._v("#")]),t._v(" v-for和v-if不建议用在一起")]),t._v(" "),e("p",[t._v("vue2中当v-for和v-if处于同一节点，v-for会先于v-if执行，造成性能浪费。")]),t._v(" "),e("p",[t._v("vue3中v-if先于v-for失效，但比起在模板层面管理相关逻辑，更好的办法是通过创建计算属性筛选出列表，并以此创建可见元素。")]),t._v(" "),e("h2",{attrs:{id:"key的作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#key的作用"}},[t._v("#")]),t._v(" key的作用")]),t._v(" "),e("p",[t._v("key的作用是为了在diff算法执行时更快的找到对应的节点，提高diff速度，更高效的更新虚拟DOM。如果没有key，那么就会采用遍历查找的方式去找到对应的旧节点。有key时速度更快。重复的key会造成渲染错误。")]),t._v(" "),e("h2",{attrs:{id:"nexttick"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nexttick"}},[t._v("#")]),t._v(" nextTick")]),t._v(" "),e("p",[t._v("Vue在"),e("strong",[t._v("更新DOM时是异步执行的")]),t._v("。只要侦听到数据变化，Vue将开启1个队列，"),e("strong",[t._v("将同一事件循环中发生的所有数据变更统一执行")]),t._v("。如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作是非常重要的。nextTick方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用")]),t._v(" "),e("h2",{attrs:{id:"插槽"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#插槽"}},[t._v("#")]),t._v(" 插槽")]),t._v(" "),e("p",[t._v("匿名插槽：没有名字的插槽，也叫默认插槽")]),t._v(" "),e("p",[t._v("具名插槽：有名字的插槽")]),t._v(" "),e("p",[t._v("作用域插槽：就是有参数的插槽，父组件通过slot-scope获取参数")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<slot name="xxx"> </slot> //具名插槽\n<slot> </slot> // 匿名插槽\n<slot data="data" > </slot> //作用域插槽\n')])])]),e("h2",{attrs:{id:"keep-alive怎么缓存的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#keep-alive怎么缓存的"}},[t._v("#")]),t._v(" keep-alive怎么缓存的")]),t._v(" "),e("p",[t._v("作用：实现组件缓存，保持这些组件的状态，以避免反复渲染导致的性能问题。 需要缓存组件 频繁切换，不需要重复渲染")]),t._v(" "),e("p",[t._v("原理：vue使用虚拟DOM，keep-alive缓存基于虚拟DOM节点储存，会将满足条件的组件在cache对象中缓存起来，在需要重新渲染时直接渲染对应虚拟DOM")]),t._v(" "),e("h2",{attrs:{id:"mixin"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mixin"}},[t._v("#")]),t._v(" mixin")]),t._v(" "),e("p",[t._v("项目越来越复杂时，多个组件之前会有重复的逻辑就会用到mixin，讲公共逻辑抽离出来，  mixin的缺点：1.变量来源不明确，不利于阅读  2.多mixin可能会造成命名冲突 3.mixin和组件可能出现多对多的关系，使得项目复杂度变高")]),t._v(" "),e("p",[t._v("在vue3中mixin被取消，使用hooks代替")]),t._v(" "),e("h2",{attrs:{id:"vuex"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vuex"}},[t._v("#")]),t._v(" Vuex")]),t._v(" "),e("p",[t._v("Vuex的状态存储是响应式的，当Vue组件从store中读取状态是，如果store的状态发生变化，那么响应的组件也会得到更新，改变store中状态的唯一途径是显式的提交（commit）mutation，方便跟踪每一个状态的变化")]),t._v(" "),e("p",[t._v("vuex有5个模块：")]),t._v(" "),e("ol",[e("li",[t._v("State：定义状态")]),t._v(" "),e("li",[t._v("Getter：过滤state中状态的数据，类似计算属性，得到的值是getter返回的值，getter 的返回值会根据它的依赖被缓存起来， 且只有当它的依赖值发生了改变才会被重新计算")]),t._v(" "),e("li",[t._v("Muatation：唯一更改state状态的方法，并且必须是同步函数否则无法跟踪到state的变化")]),t._v(" "),e("li",[t._v("Action：用于提交mutation，不是直接更改状态，因此可以执行异步操作")]),t._v(" "),e("li",[t._v("Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中")])]),t._v(" "),e("h2",{attrs:{id:"修饰符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#修饰符"}},[t._v("#")]),t._v(" 修饰符")]),t._v(" "),e("p",[t._v("修饰符有五种：表单修饰符、事件修饰符、鼠标按键修饰符、键值修饰符、v-bind修饰符")]),t._v(" "),e("h3",{attrs:{id:"表单修饰符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#表单修饰符"}},[t._v("#")]),t._v(" 表单修饰符")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("lazy：光标离开标签的时候，才会将值赋予给value，也就是在change事件之后再进行信息同步")])]),t._v(" "),e("li",[e("p",[t._v("trim：自动过滤用户输入的首空格字符，而中间的空格不会过滤")])]),t._v(" "),e("li",[e("p",[t._v("number：自动将用户的输入值转为数值类型，但如果这个值无法被parseFloat解析，则会返回原来的值")])])]),t._v(" "),e("h3",{attrs:{id:"事件修饰符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件修饰符"}},[t._v("#")]),t._v(" 事件修饰符")]),t._v(" "),e("ul",[e("li",[t._v("stop：阻止了事件冒泡，相当于调用了event.stopPropagation方法")])]),t._v(" "),e("ul",[e("li",[t._v("prevent：阻止了事件的默认行为，相当于调用了event.preventDefault方法")]),t._v(" "),e("li",[t._v("self：只当在 event.target 是当前元素自身时触发处理函数")]),t._v(" "),e("li",[t._v("once：绑定了事件以后只能触发一次，第二次就不会触发")]),t._v(" "),e("li",[t._v("passive：当我们在监听元素滚动事件的时候，会一直触发onscroll事件会让我们的网页变卡，因此我们使用这个修饰符的时候，相当于给onscroll事件整了一个.lazy修饰符。不要把 .passive 和 .prevent 一起使用,因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。passive 会告诉浏览器你不想阻止事件的默认行为")]),t._v(" "),e("li",[t._v("native：让组件变成像html内置标签那样监听根元素的原生事件，否则组件上使用 v-on 只会监听自定义事件")])]),t._v(" "),e("h3",{attrs:{id:"鼠标修饰符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#鼠标修饰符"}},[t._v("#")]),t._v(" 鼠标修饰符")]),t._v(" "),e("ul",[e("li",[t._v("left 左键点击")]),t._v(" "),e("li",[t._v("right 右键点击")]),t._v(" "),e("li",[t._v("middle 中键点击")])]),t._v(" "),e("h3",{attrs:{id:"键值修饰符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#键值修饰符"}},[t._v("#")]),t._v(" 键值修饰符")]),t._v(" "),e("p",[t._v("键盘修饰符是用来修饰键盘事件（onkeyup，onkeydown）的keyCode存在很多，但vue为我们提供了别名，分为以下两种：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("普通键（enter、tab、delete、space、esc、up...）")])]),t._v(" "),e("li",[e("p",[t._v("系统修饰键（ctrl、alt、meta、shift...）")])])]),t._v(" "),e("p",[t._v("可以通过以下方式自定义一些全局的键盘码别名")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Vue.config.keyCodes.f2 = 113\n")])])]),e("h3",{attrs:{id:"v-bind修饰符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#v-bind修饰符"}},[t._v("#")]),t._v(" v-bind修饰符")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("async：对props进行一个双向绑定（相当于vue3中v-model）")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<comp :myMessage.sync="bar"></comp>//相当于\n<comp :myMessage="bar" @update:myMessage="func"></comp>\nfunc(e){this.bar = e;}\n')])])])])]),t._v(" "),e("p",[t._v("将 v-bind.sync 用在一个字面量的对象上，例如 v-bind.sync=”{ title: doc.title }”，是无法正常工作的")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("prop：设置自定义标签属性，避免暴露数据，防止污染HTML结构")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<input id="uid" title="title1" value="1" :index.prop="index">\n')])])])])]),t._v(" "),e("h1",{attrs:{id:"react"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react"}},[t._v("#")]),t._v(" React")]),t._v(" "),e("h2",{attrs:{id:"class组件和函数组件的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#class组件和函数组件的区别"}},[t._v("#")]),t._v(" class组件和函数组件的区别")]),t._v(" "),e("p",[t._v("类组件是使用class来定义的组件吗，函数组件是接受一个单一的props对象并返回一个jsx")]),t._v(" "),e("p",[t._v("关于react的二者区别是，类组件使用类组件的api，函数式组件使用hooks，官方推荐使用hooks而不是类，因为hook更加简洁，代码量少，比类轻量，而且hooks是函数更加符合react函数式的本质")]),t._v(" "),e("p",[t._v("类组件的缺点：")]),t._v(" "),e("p",[t._v("大型组件很难拆分和重构，业务逻辑分散在组件各个方法中，导致重复逻辑和关联逻辑。")]),t._v(" "),e("p",[e("strong",[t._v("区别：")])]),t._v(" "),e("p",[t._v("函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。")]),t._v(" "),e("p",[t._v("1.状态的有无  hooks出现之前，函数组件没有实例，没有生命周期，没有state，没有this，，所以我们称函数组件为无状态组件。 hooks出现之前，react中的函数组件通常只考虑负责UI的渲染，没有自身的状态没有业务逻辑代码，是一个纯函数。它的输出只由参数props决定，不受其他任何因素影响。")]),t._v(" "),e("p",[t._v("2.调用方式的不同  函数组件重新渲染，将重新调用组件方法返回新的react元素。类组件重新渲染将new一个新的组件实例，然后调用render类方法返回react元素，这也说明为什么类组件中this是可变的。")]),t._v(" "),e("p",[t._v("3.因为调用方式不同，在函数组件使用中会出现问题  在操作中改变状态值，类组件可以获取最新的状态值，而函数组件则会按照顺序返回状态值")]),t._v(" "),e("p",[t._v("常用Hooks：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("useState() //状态钩子\nuseContext()//共享状态钩子\nuseReducer() //action钩子\nuseEffect()/副作用钩子\n")])])]),e("h2",{attrs:{id:"react组件通信方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react组件通信方式"}},[t._v("#")]),t._v(" react组件通信方式")]),t._v(" "),e("p",[t._v("父向子：props")]),t._v(" "),e("p",[t._v("子向父：props+回调的方式，使用公共组件进行状态提升。子传父是先在父组件上绑定属性设置为一个函数，当子组件需要给父组件传值的时候，则通过props调用该函数将参数传入到该函数当中，此时就可以在父组件中的函数中接收到该参数了，这个参数则为子组件传过来的值")]),t._v(" "),e("p",[t._v("跨级组件通信（爷向孙？）：props的层层传递、使用context，context相当于一个大容器，我们可以把要通信的内容放在这个容器中，这样不管嵌套多深，都可以随意取用，对于跨越多层的全局数据可以使用context实现。【类似provide】")]),t._v(" "),e("p",[t._v("非嵌套关系的组件通信：")]),t._v(" "),e("ul",[e("li",[t._v("自定义事件通信（发布订阅模式），使用pubsub-js")]),t._v(" "),e("li",[t._v("redux等进行全局状态管理")]),t._v(" "),e("li",[t._v("兄弟组件通信，可以找到这两个兄弟节点共同的父节点, 结合父子间通信方式进行通信。")]),t._v(" "),e("li",[t._v("new一个 Vue 的 EventBus,进行事件监听，一边执行监听，一边执行新增 VUE的eventBus 就是发布订阅模式，是可以在React中使用的;")])]),t._v(" "),e("h2",{attrs:{id:"setstate是异步还是同步"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#setstate是异步还是同步"}},[t._v("#")]),t._v(" setState是异步还是同步")]),t._v(" "),e("p",[t._v("都可能，在react事件当中是异步操作，在settimeout事件或者自定义的dom事件中是同步的")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 自定义事件\ndocument.querySelector('#btn').addEventListener('click',()=>{\n            this.setState({\n                count: this.state.count + 1\n            });\n            console.log(this.state.count);\n});\n")])])]),e("h2",{attrs:{id:"生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[t._v("#")]),t._v(" 生命周期")]),t._v(" "),e("p",[t._v("组件的实例被创建并插入到 DOM 中时，这些方法按以下顺序调用：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("constructor()\nstatic getDerivedStateFromProps()\nrender()\ncomponentDidMount()\n")])])]),e("p",[t._v("更新可能由道具或状态的更改引起。当重新渲染组件时，这些方法按以下顺序调用：")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("getDerivedStateFromProps")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("shouldComponentUpdate")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("render")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("getSnapshotBeforeUpdate")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("componentDidUpdate")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),e("p",[t._v("当组件从 DOM 中移除时调用此方法：")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[t._v("componentWillUnmount")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),e("h2",{attrs:{id:"react-filber"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-filber"}},[t._v("#")]),t._v(" react-filber")]),t._v(" "),e("p",[t._v("JS 运算、页面布局和页面绘制都是运行在浏览器的主线程当中，他们之间是互斥的关系。**如果 JS 运算持续占用主线程，页面就没法得到及时的更新。**更新页面的时候，React 会遍历应用的所有节点，计算出差异，然后再更新 UI。如果页面元素很多，整个过程占用的时机就可能超过 16 毫秒，就容易出现掉帧的现象。react-filber因此而产生")]),t._v(" "),e("p",[e("strong",[t._v("实现原理：")])]),t._v(" "),e("p",[t._v("react内部运转分三层：")]),t._v(" "),e("ul",[e("li",[t._v("虚拟DOM 层，描述页面长什么样。")]),t._v(" "),e("li",[t._v("Reconciler 层，负责调用组件生命周期方法，进行 Diff 运算等。")]),t._v(" "),e("li",[t._v("Renderer 层，根据不同的平台，渲染出相应的页面，比较常见的是 ReactDOM 和 ReactNative。")])]),t._v(" "),e("p",[t._v("filber其实指的是一种数据结构，可以用一个js对象来表示")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("{\n    stateNode,//节点实例\n    child,    //子节点\n    sibling   //兄弟节点\n    return    // 父节点\n}\n")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);